%% SG_accretion
% Calculate accretion rates used by the SAM single-moment microphysics
% scheme.
%
% Tristan Abbott // Massachusetts Institute of Technology // 03/30/2018
%
%%% Syntax
%   [a, ac, ai, arc, asc, agc, ari, asi, agi] = SG_autoconversion(grid, 'tabs', 'qp', 'qn')
%
%%% Description
% Computes accretion rates based on the SAM single-moment microphysics scheme.
% Details about the SAM model and microphysics are given in in Appendix A of 
% Khairoutdinov and Randall, 2003: "Cloud Resolving
% Modeling of the ARM Summer 1997 IOP: Model Formulation, Results, 
% Uncertainties, and Sensitivities", _Journal of the Atmospheric Sciences_. 
%
% All inputs can be multidimensional. If multidimensional input
% is given, all inputs must be the same shape and size and the function will
% operate element-wise.
%
%%% Input Arguments
%
% *grid - SAM C-grid struct:*
% A struct containing grid information generated by SG_grid and fields
% added by SG_addVar.
%
% *tabs, qp, qn - names of fields:*
% String keys that can be used to look up absolute temperature, precipitating
% water specific humidity, and cloud water specific humidity.
%
%%% Output Arguments
% *a - total accretion rate:*
% Total autoconversion for all species of precipitating condensate and all
% cloud types. Has units of 1/s.
%
% *ac - accretion rate from liquid cloud*
% *ai - accretion rate from ice cloud*
% *arc - accretion rate, rain from liquid cloud*
% *asc - accretion rate, snow from liquid cloud*
% *agc - accretion rate, graupel from liquid cloud*
% *ari - accretion rate, rain from ice cloud*
% *asi - accretion rate, snow from ice cloud*
% *agi - accretion rate, graupel from ice cloud*
%
%%% Source code
function [a, ac, ai, arc, asc, agc, ari, asi, agi] = ...
    SG_accretion(grid, tabs, qp, qn)

    % Add global variables
    global SOM_alpha;
    global SOM_beta;
    global SOM_q_co;
    global SOM_q_io;
    global SOM_T_00n;
    global SOM_T_0n;
    global SOM_a_r;
    global SOM_a_s;
    global SOM_a_g;
    global SOM_b_r;
    global SOM_b_s;
    global SOM_b_g;
    global SOM_N_0r;
    global SOM_N_0s;
    global SOM_N_0g;
    global SOM_T_0p;
    global SOM_T_00p;
    global SOM_T_0g;
    global SOM_T_00g;
    global SOM_rho_r;
    global SOM_rho_s;
    global SOM_rho_g;
    global SOM_rho_0;
    global SOM_E_rc;
    global SOM_E_sc;
    global SOM_E_gc;
    global SOM_E_ri;
    global SOM_E_si;
    global SOM_E_gi;
    
    % Compute density
    rho = repmat(grid.rho, [1 grid.ny grid.nx]);
    
    % Compute mixing ratios of different forms of precipitation
    op = SOM_omega(grid.(tabs), SOM_T_0p, SOM_T_00p);
    qr = op.*grid.(qp);
    og = SOM_omega(grid.(tabs), SOM_T_0g, SOM_T_00g);
    qs = (1 - op).*(1 - og).*grid.(qp);
    qg = (1 - op).*og.*grid.(qp);
    
    % Compute mixing ratios of different forms of cloud water
    on = SOM_omega(grid.(tabs), SOM_T_0n, SOM_T_00n);
    qc = on.*grid.(qn);
    qi = (1 - on).*grid.(qn);
    
    % Compute accretion rates
    arc = (pi/4).*SOM_a_r.*SOM_N_0r.*SOM_E_rc.*gamma(3 + SOM_b_r).* ...
        (SOM_rho_0./rho).^(1/2) .* ...
        (rho./(pi*SOM_rho_r.*SOM_N_0r)).^((3 + SOM_b_r)/4) .* ...
        qc .* (qr).^((3 + SOM_b_r)/4);
    agc = (pi/4).*SOM_a_g.*SOM_N_0g.*SOM_E_gc.*gamma(3 + SOM_b_g).* ...
        (SOM_rho_0./rho).^(1/2) .* ...
        (rho./(pi*SOM_rho_g.*SOM_N_0g)).^((3 + SOM_b_g)/4) .* ...
        qc .* (qg).^((3 + SOM_b_s)/4);
    asc = (pi/4).*SOM_a_s.*SOM_N_0s.*SOM_E_sc.*gamma(3 + SOM_b_s).* ...
        (SOM_rho_0./rho).^(1/2) .* ...
        (rho./(pi*SOM_rho_s.*SOM_N_0s)).^((3 + SOM_b_s)/4) .* ...
        qc .* (qs).^((3 + SOM_b_g)/4);
    fac_ice = exp(0.025.*(grid.(tabs) - 273.16));
    ari = fac_ice .* ...
        (pi/4).*SOM_a_r.*SOM_N_0r.*SOM_E_ri.*gamma(3 + SOM_b_r).* ...
        (SOM_rho_0./rho).^(1/2) .* ...
        (rho./(pi*SOM_rho_r.*SOM_N_0r)).^((3 + SOM_b_r)/4) .* ...
        qi .* (qr).^((3 + SOM_b_r)/4);
    agi = fac_ice .* ...
        (pi/4).*SOM_a_g.*SOM_N_0g.*SOM_E_gi.*gamma(3 + SOM_b_g).* ...
        (SOM_rho_0./rho).^(1/2) .* ...
        (rho./(pi*SOM_rho_g.*SOM_N_0g)).^((3 + SOM_b_g)/4) .* ...
        qi .* (qs).^((3 + SOM_b_s)/4);
    asi = fac_ice .* ...
        (pi/4).*SOM_a_s.*SOM_N_0s.*SOM_E_si.*gamma(3 + SOM_b_s).* ...
        (SOM_rho_0./rho).^(1/2) .* ...
        (rho./(pi*SOM_rho_s.*SOM_N_0s)).^((3 + SOM_b_s)/4) .* ...
        qi .* (qg).^((3 + SOM_b_g)/4);
    ac = arc + agc + asc;
    ai = ari + agi + asi;
    a = ac + ai;

end
