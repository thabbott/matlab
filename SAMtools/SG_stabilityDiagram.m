%% SG_stabilityDiagram
% Compute a stability diagram for undilute ascent in each column
%
% Tristan Abbott // Massachusetts Institute of Technology // 2/27/2018
%
%%% Syntax
%   dTv = SG_stabilityDiagram(grid, 'T', 'qv', 'qn', 'qp');
%
%%% Description
% Computes the density difference (measured as a density temperature difference)
% between the large-scale environment (defined as a horizontal averaged) as a parcel
% lifted from level p_i to level p. The difference is returned as a 4D matrix 
% Tp(np, np, ny, nx). The first dimension gives the initial parcel level,
% the second dimension gives the final parcel level, and the last two dimensions
% index into different columns. Each element gives the density temperature difference
% that results from lifting a parcel in column (ny,nx) from the initial parcel
% level to the final parcel level.
%
% An example of a stability diagram is given in Figure 6.4 of Atmospheric
% Convection (Emanuel, 1994). As of 2/27/2018, this function only computes the
% portion of the stability diagram shown above the diagonal black line.
%
%%% Input Arguments
% *grid - SAM C-grid struct:*
% A struct containing grid information generated by SG_grid and fields
% added by SG_addVar.
%
% *T, qv, qn, qp - names of fields:*
% String keys that can be used to look up absolute temperature, water vapor,
% cloud condensate, and precipitating condensate.
%
%%% Output Arguments
%
% *dTv - stability diagram:*
% 4D array containing a stability diagram, as described above, with parcel
% buoyancies given as a density temperature anomaly.
%

function dTv = SG_stabilityDiagram(grid, T, qv, qn, qp)
    
    d = size(grid.(T));
    dTv = zeros([d(1) d(1) d(2) d(3)]);
    epsv = 0.61; % Correct if dosmoke was .false. in run
                 % Should be 0 otherwise

    % Compute horizontal averages
    T0 = mean(mean(grid.(T), 2),3);
    qv0 = mean(mean(grid.(qv),2),3);
    qn0 = mean(mean(grid.(qn),2),3);
    qp0 = mean(mean(grid.(qp),2),3);

    % Compute FMSE field
    hL = SG_hL(grid, T, qn, qp);

    % Iterate upward from surface
    for ii = 1:d(1)
        
        % Compute moist adiabatic profile starting from current level
        vars = SOM_moistAdiabat(squeeze(hL(ii,:,:)), ...
            squeeze(grid.(qv)(ii,:,:) + grid.(qn)(ii,:,:)), ...
            squeeze(grid.(qp)(ii,:,:)), reshape(grid.z, [1 1 d(1)]), ...
            permute(grid.pp, [2 3 1]));
        qvp = permute(repmat(squeeze(grid.(qv)(ii,:,:) + ...
            grid.(qn)(ii,:,:)), ...
            [1 1 d(1)]) - vars.qn, [3 1 2]);
        qpp = repmat(grid.(qp)(ii,:,:), [d(1) 1 1]);
        qnp = permute(vars.qn, [3 1 2]);
        Tp = permute(vars.T, [3 1 2]);

        % Compute profile buoyancy.
        dTv(ii,:,:,:) = T0.*(epsv*(qvp-qv0) - (qnp-qn0 + qpp-qp0)) + ...
               (Tp-T0).*(1 + epsv*qv0 - qn0 - qp0);
        if ii > 1
            dTv(ii,1:ii-1,:,:) = NaN; % Flag levels below starting level
        end

    end

end
