%% SG_verticalIntegral
% Compute a vertical integral of a quantity located on the SAM C-grid.
%
% Tristan Abbott // Massachusetts Institute of Technology // 11/14/2017
%
%%% Syntax
%   res = SG_verticalIntegral(grid, 'T', 's', 'mass');
%
%%% Description
% Compute vertical integrals of a quantity located
% on the SAM C-grid. Different weighting schemes can be specified; by
% default, the integral is mass-weighted. It is also possible to specify
% whether the quantity is located at vertical velocity levels or scalar
% levels.
%
%%% Input Arguments
% *grid - SAM C-grid struct:*
% A struct containing grid information generated by SG_grid and fields
% added by SG_addVar.
%
% *s - name of quantity being integrated:*
% String keys that can be used to look up the field being integrated in the
% grid struct.
%
% *loc - location of field on the C-grid:*
% String containing the location of the field on the C-grid. Possibilities
% are 's' (at scalar levels) or 'w' (at vertical velocity levels).
%
% *weighting - weighting of vertical integral:*
% String specifying how the integral is weighted. Possbilities are 'mass'
% (integral of rho dz) or 'none' (integral dz).
%
%%% Output Arguments
%
% *res - integrated quantity:*
% 2D array containing the column-integrated field.

function res = SG_verticalIntegral(grid, s, loc, weighting)

    switch lower(loc)
        case 's'
            switch lower(weighting)
                case 'mass'
                    res = int_s_mass(grid, s);
                case 'none'
                    res = int_s_none(grid, s);
                otherwise
                    error(['SG_verticalIntegral: ', ...
                        'unsupported options loc = %s, weighting = %s'], ...
                        loc, weighting);
            end
        case 'w'
            switch lower(weighting)
                case 'mass'
                    res = int_w_mass(grid, s);
                case 'none'
                    res = int_w_none(grid, s);
                otherwise
                    error(['SG_verticalIntegral: ', ...
                        'unsupported options loc = %s, weighting = %s'], ...
                        loc, weighting);
            end
        otherwise
            error('SG_verticalIntegral: unsupported option loc = %s', ...
                loc);
    end
end

function res = int_s_mass(grid, s)
    nx = size(grid.(s), 3); ny = size(grid.(s), 2);
    dz = grid.zi(2:end) - grid.zi(1:end-1);
    dz3d = repmat(dz, [1 ny nx]);
    res = squeeze(sum(dz3d.*grid.rho.*grid.(s), 1));
end

function res = int_s_none(grid, s)
    nx = size(grid.(s), 3); ny = size(grid.(s), 2);
    dz = grid.zi(2:end) - grid.zi(1:end-1);
    dz3d = repmat(dz, [1 ny nx]);
    res = squeeze(sum(dz3d.*grid.(s), 1));
end

function res = int_w_mass(grid, s)
    nx = size(grid.(s), 3); ny = size(grid.(s), 2); nz = size(grid.(s), 1);
    dz = zeros(nz, 1);
    dz(1) = grid.z(1);
    dz(2:end-1) = grid.z(2:end) - grid.z(1:end-1);
    dz(end) = grid.zi(end) - grid.z(end);
    dz3d = repmat(dz, [1 ny nx]);
    res = squeeze(sum(dz3d.*repmat(grid.rhoi, [1 ny nx]).*grid.(s), 1));
end

function res = int_w_none(grid, s)
    nx = size(grid.(s), 3); ny = size(grid.(s), 2); nz = size(grid.(s), 1);
    dz = zeros(nz, 1);
    dz(1) = grid.z(1);
    dz(2:end-1) = grid.z(2:end) - grid.z(1:end-1);
    dz(end) = grid.zi(end) - grid.z(end);
    dz3d = repmat(dz, [1 ny nx]);
    res = squeeze(sum(dz3d.*grid.(s), 1));
end
