%% SG_oceflx
% Compute surface fluxes.
%
% Tristan Abbott // Massachusetts Institute of Technology // 3/3/2018
%
%%% Syntax
%   [lhf, shf] = SG_oceflx(grid, 'u', 'v', 'tabs', 'qv', 'qn', 'qp', 'sst');
%
%%% Description
% Compute surface latent and sensible heat fluxes following SAM's oceflx.f90.
% Currently assumes salt_factor == 1; no seawater correction.
%
%%% Input Arguments
% *grid - SAM C-grid struct:*
% A struct containing grid information generated by SG_grid and fields
% added by SG_addVar.
%
% *u, v, tabs, qv, qn, qp, sst - names of fields:*
% String keys that can be used to look up u and v velocity fields, temperature,
% water species (vapor, cloud, and precipitating, respectively), and
% surface temperature. The surface temperature field must be oriented per
% SG_* conventions with a singleton first dimension.
%
%%% Output Arguments
%
% *lhf, shf - surface heat fluxes:*
% 3D arrays (with a singleton first dimension) containing heat fluxes under
% scalar columns. SHF units are K*m/s (convert to W/m^2 by multiplying by
% grid.rhoi(1)*SAM_c_p); LHF units are kg/kg*m/s (convert to W/m^2 by 
% multiplying by grid.rhoi(1)*SAM_L_c).
%

function [lhf, shf] = SG_oceflx(grid, u, v, tabs, qv, qn, qp, sst)
%function [lhf, shf] = SG_oceflx(grid, u, v, hL, qv, sst)
    
    % Set global variables
    global SAM_c_p;
    global SAM_g;

    % Compute surface fields used in oceflx.f90
    ubot = squeeze(0.5*(grid.(u)(1,:,1:end-1) + grid.(u)(1,:,2:end)));
    vbot = squeeze(0.5*(grid.(v)(1,1:end-1,:) + grid.(v)(1,2:end,:)));
    hL = SG_hL(grid, tabs, qn, qp);
    % hL = grid.(hL);
    tbot = squeeze(hL(1,:,:) - SAM_g*grid.z(1))/SAM_c_p;
    % tbot = squeeze(hL(1,:,:)) - SAM_g*grid.z(1)/SAM_c_p;
    qbot = squeeze(grid.(qv)(1,:,:));
    thbot = squeeze(hL(1,:,:))/SAM_c_p;
    % thbot = squeeze(hL(1,:,:));
    pmidm1 = grid.p(1).*ones(size(qbot)); % NOTE: in mb
    zbot = grid.z(1).*ones(size(qbot));
    ts = squeeze(grid.sst);

    % Set parameters used in oceflx.f90
    xkar = 0.4;
    zref = 10.0;
    umin = 1.0;
    ztref = 2.0;
    salt_factor = 1.0;

    % Alias functions to names used in oceflx.f90
    % Recall that SAM_qsat* functions expect p in Pa.
    qsatw = @(T,p) SAM_qsatWater(T,1e2*p);
    qsati = @(T,p) SAM_qsatIce(T,1e2*p);

    % Define statement functions used in oceflx.f90
    cdn = @(Umps) 0.0027 ./ Umps + .000142 + .0000764 .* Umps;
    psimhu = @(xd) log((1.+xd.*(2.+xd)).*(1.+xd.*xd)/8.) - 2.*atan(xd) + 1.571;
    psixhu = @(xd) 2. * log((1. + xd.*xd)/2.);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%               Begin code copied from oceflx.f90                   %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%!---------------------------------------------------------------
%! Set up necessary variables
%!---------------------------------------------------------------

         rbot = pmidm1*100.  ./ (287.*tbot );
         vmag   = max(umin, sqrt(ubot.^2+vbot.^2));
         thvbot = thbot  .* (1.0 + 0.606*qbot );
         delt   = thbot  - ts;
         if (ts > 271.)
	        ssq = salt_factor*qsatw(ts,pmidm1); 
         else
	        ssq = qsati(ts,pmidm1); 
         end
         delq   = qbot  - ssq;  
         alz    = log(zbot/zref); 
         cp     = 1005.;
	     gravit = 9.81;
	     ltheat = 2.51e6;
%!---------------------------------------------------------------
%! First iteration to converge on Z/L and hence the fluxes
%!---------------------------------------------------------------

%! Initial guess for roots of neutral exchange coefficients, 
%! assume z/L=0. and u10n is approximated by vmag.
%! Stable if (thbot > ts ).

         stable = 0.5 + 0.5*sign(delt);
         rdn  = sqrt(cdn(vmag));
         rhn  = (1.-stable) * 0.0327 + stable * 0.018;
         ren  = 0.0346;

%! Initial guess of ustar,tstar and qstar

         ustar = rdn.*vmag;
         tstar = rhn.*delt;
         qstar = ren.*delq;

%! Compute stability and evaluate all stability functions
%! Stable if (thbot > ts or hol > 0 )

         hol = xkar.*gravit.*zbot.*...
            (tstar./thvbot+qstar./(1./0.606+qbot))./ustar.^2;
         hol = min(abs(hol),10.).*sign(hol);
         stable = 0.5 + 0.5*sign(hol);
         xsq   = max(sqrt(abs(1. - 16.*hol)), 1.);
         xqq   = sqrt(xsq);
         psimh = -5. * hol .* stable + (1.-stable).*psimhu(xqq);
         psixh = -5. * hol .* stable + (1.-stable).*psixhu(xqq);

%! Shift 10m neutral wind speed using old rdn coefficient

         rd   = rdn ./ (1.+rdn./xkar.*(alz-psimh));
         u10n = vmag .* rd ./ rdn;

%! Update the neutral transfer coefficients at 10m and neutral stability

         rdn = sqrt(cdn(u10n));
         ren = 0.0346;
         rhn = (1.-stable) * 0.0327 + stable * 0.018;

%! Shift all coeffs to measurement height and stability

         rd = rdn ./ (1.+rdn./xkar.*(alz-psimh)); 
         rh = rhn ./ (1.+rhn./xkar.*(alz-psixh)); 
         re = ren ./ (1.+ren./xkar.*(alz-psixh));

%! Update ustar, tstar, qstar using updated, shifted coeffs 

         ustar = rd .* vmag; 
         tstar = rh .* delt; 
         qstar = re .* delq; 

%!---------------------------------------------------------------
%! Second iteration to converge on Z/L and hence the fluxes
%!---------------------------------------------------------------

%! Recompute stability & evaluate all stability functions  
%! Stable if (thbot > ts or hol > 0 )
 
         hol = xkar.*gravit.*zbot.*...
            (tstar./thvbot+qstar./(1./0.606+qbot))./ustar.^2;
         hol = min(abs(hol),10.).*sign(hol);
         stable = 0.5 + 0.5.*sign(hol);
         xsq   = max(sqrt(abs(1. - 16.*hol)) , 1.);
         xqq   = sqrt(xsq);
         psimh = -5. * hol .* stable + (1.-stable).*psimhu(xqq);
         psixh = -5. * hol .* stable + (1.-stable).*psixhu(xqq);

%! Shift 10m neutral wind speed using old rdn coefficient

         rd   = rdn ./ (1.+rdn./xkar.*(alz-psimh));
         u10n = vmag .* rd ./ rdn;

%! Update the neutral transfer coefficients at 10m and neutral stability

         rdn = sqrt(cdn(u10n));
         ren = 0.0346;
         rhn = (1.-stable) * 0.0327 + stable * 0.018; 

%! Shift all coeffs to measurement height and stability

         rd = rdn ./ (1.+rdn./xkar.*(alz-psimh)); 
         rh = rhn ./ (1.+rhn./xkar.*(alz-psixh)); 
         re = ren ./ (1.+ren./xkar.*(alz-psixh));

%!---------------------------------------------------------------
%! Compute the fluxes
%!---------------------------------------------------------------

%! Update ustar, tstar, qstar using updated, shifted coeffs 

         ustar = rd .* vmag; 
         tstar = rh .* delt; 
         qstar = re .* delq; 

%! Compute surface stress components

         tau   =  rbot  .* ustar .* ustar; 
         taux  = -tau .* ubot  ./ vmag; 
         tauy  = -tau .* vbot  ./ vmag; 

%! Compute heat flux components at current surface temperature
%! (Define positive latent and sensible heat as upwards into the atm)

         shf  = -tau .* tstar ./ ustar ./ rbot;
         lhf  = -tau .* qstar ./ ustar ./ rbot;

% %!---------------------------------------------------------------
% %! Following Geleyn(1988), interpolate ts to fixed height zref
% %!---------------------------------------------------------------
% 
% %! Compute function of exchange coefficients. Assume that 
% %! cn = rdn*rdn, cm=rd*rd and ch=rh*rd, and therefore 
% %! 1/sqrt(cn )=1/rdn and sqrt(cm )/ch =1/rh 
% 
%          bn = xkar/rdn
%          bh = xkar/rh
% 
% %! Interpolation factor for stable and unstable cases
% 
%          ln0 = log(1.0 + (ztref/zbot )*(exp(bn) - 1.0))
%          ln3 = log(1.0 + (ztref/zbot )*(exp(bn - bh) - 1.0))
%          fac = (ln0 - ztref/zbot *(bn - bh))/bh * stable &
%              + (ln0 - ln3)/bh * (1.-stable)
%          fac = min(max(fac,0.),1.)
% 
% %! Actual interpolation
% 
%          tref  = ts  + (tbot  - ts )*fac

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%               End code copied from oceflx.f90                   %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Set outputs
    lhf = reshape(lhf, [1 size(lhf,1) size(lhf,2)]);
    shf = reshape(shf, [1 size(shf,1) size(shf,2)]);

end
