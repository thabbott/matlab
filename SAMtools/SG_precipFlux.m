%% SG_precipFlux
% Calculate precipitation fluxes based on the SAM single-moment 
% microphysics scheme.
%
% Tristan Abbott // Massachusetts Institute of Technology // 01/30/2016
%
%%% Syntax
%   [f, f_r, f_s, f_g] = SG_precipFlux(grid, 'tabs', 'qp')
%
%%% Description
% Calculates downward precipitation fluxes given a precipitable water 
% specific humidity field and a temperature (for hydrometeor partitioning
% between phases). The calculations are
% performed based on the SAM single-moment microphysics scheme.
% Details about the SAM model and microphysics are given in in Appendix A of 
% Khairoutdinov and Randall, 2003: "Cloud Resolving
% Modeling of the ARM Summer 1997 IOP: Model Formulation, Results, 
% Uncertainties, and Sensitivities", _Journal of the Atmospheric Sciences_. 
%
% All inputs can be multidimensional. If multidimensional input
% is given, all inputs must be the same shape and size and the function will
% operate element-wise.
%
%%% Input Arguments
%
% *grid - SAM C-grid struct:*
% A struct containing grid information generated by SG_grid and fields
% added by SG_addVar.
%
% *tabs, qp - names of fields:*
% String keys that can be used to look up absolute temperature and
% precipitating condensate.
%
%%% Output Arguments
% *f - total precipitation flux:*
% Total instantaneous downward precipitation flux (rain, snow, and graupel
% combined). Has units of kg m^2 / s.
%
% *f_r - precipitation flux from rain:*
% Contribution to f from rain. Has units of kg m^2 / s.
%
% *f_s - precipitation flux from snow:*
% Contribution to f from snow. Has units of kg m^2 / s.
%
% *f_g - precipitation flux from graupel:*
% Contribution to f from graupel. Has units of kg m^2 / s.
%
%%% Source code
function [f, f_r, f_s, f_g] = SG_precipFlux(grid, tabs, qp)

    % Add global variables
    global SOM_a_r;
    global SOM_a_s;
    global SOM_a_g;
    global SOM_b_r;
    global SOM_b_s;
    global SOM_b_g;
    global SOM_N_0r;
    global SOM_N_0s;
    global SOM_N_0g;
    global SOM_T_0p;
    global SOM_T_00p;
    global SOM_T_0g;
    global SOM_T_00g;
    global SOM_rho_r;
    global SOM_rho_s;
    global SOM_rho_g;
    global SOM_rho_0;
    global SAM_R;
    
    % Compute density
    rho = repmat(reshape(grid.rho, [1 1 grid.nzm]), [grid.nx grid.ny 1]);
    
    % Compute mixing ratios of different forms of precipitation
    op = SOM_omega(permute(grid.tabs, [3 2 1]), SOM_T_0p, SOM_T_00p);
    q_r = op.*permute(grid.qp, [3 2 1]);
    og = SOM_omega(permute(grid.tabs, [3 2 1]), SOM_T_0g, SOM_T_00g);
    q_s = (1 - op).*(1 - og).*permute(grid.qp, [3 2 1]);
    q_g = (1 - op).*og.*permute(grid.qp, [3 2 1]);
    
    % Compute fluxes from different forms of precipitation
    f_r = (SOM_a_r .* gamma(4 + SOM_b_r))./6 .* ...
        (pi.*SOM_rho_r.*SOM_N_0r).^(-SOM_b_r/4) .* ...
        (SOM_rho_0 ./ rho).^(0.5) .* ...
        (rho .* q_r).^(1 + SOM_b_r/4);
    f_s = (SOM_a_s .* gamma(4 + SOM_b_s))./6 .* ...
        (pi.*SOM_rho_s.*SOM_N_0s).^(-SOM_b_s/4) .* ...
        (SOM_rho_0 ./ rho).^(0.5) .* ...
        (rho .* q_s).^(1 + SOM_b_s/4);
    f_g = (SOM_a_g .* gamma(4 + SOM_b_g))./6 .* ...
        (pi.*SOM_rho_g.*SOM_N_0g).^(-SOM_b_g/4) .* ...
        (SOM_rho_0 ./ rho).^(0.5) .* ...
        (rho .* q_g).^(1 + SOM_b_g/4);

    % Reshape for SG conventions
    f_r = permute(f_r, [3 2 1]);
    f_s = permute(f_s, [3 2 1]);
    f_g = permute(f_g, [3 2 1]);

	% Compute total flux
    f = f_r + f_s + f_g;

end
